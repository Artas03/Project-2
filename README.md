# MOT Generator - SFIA 2

## Contents

* Introduction
* Project Planning
   * Trello Board
   * Risk Assessment
   * ERD Diagram
   * CI pipeline diagram
* Software Structure
  * Services Setup
  * Swarm Configuration
  * Jenkins
* Unit Testing
* Ansible Deployment
* Jenkins Deployment
* GitHub merging
* Improvements
* Licensing


## Introduction

The aim of this project was to create a web based functioning app that would meet the SFIA requirements, working on a service architecture.

The application programmed for this project runs across four services, with service 1 being the frontend service with which the user can interact wiht and services 2,3 and 4 being the backend services that generate random varibales and commit them to the database.

Service-1 contains HTML files that give the user a visual of the application working, this service makes the get requests to the other services and relays information to and from the database. Service 2 generates a random make of a vehicle, service 3 generates a random model of a vehicle and service 4 combines the make and model generated and assigns an MOT due date (in months) based on the number of vowels present in the name of the randomly generated vehicle. 

## Project Planning


**Trello Board**

![Trello](https://i.imgur.com/eUluZIN.png)
The trello board was used to carry out agile practices in order to create a methodical and organised plan for the project. From the first picture above we can see how the project is progressing with majority of the services completed at this point and majority of diagrams completed. Each of these task contained a user story, which incorporated an '_As a User_', '_I want_', '_so that_', features that allow correct assessment whether each task has been completed.

![Trello2](https://i.imgur.com/itfF2mF.png)
The picture of the trello board above is an evolution of the first trello board, as this one incorporates the inclusion of an external NGINX load balancer. This is something that was added to the project midway and as a result had to be assigned to the trello board to incorporate it correctly within schedule.

**Risk Assessment**

![RiskAssessment](https://i.imgur.com/mFCCVUw.png)
Above is a risk assessment that was created at the beginning of the project as part of the project planning with the risks being the ones that were anticipated at the time.

![RiskAssessment2](https://i.imgur.com/9i3dlSO.png)
Above is an evolved version of the risk assessment which contains some additional risks that were encountered during the execution of this project. It is important to update new risks to make sure progress is not affected in the future. 

**ERD Diagram**

![ERDDiagram](https://i.imgur.com/pYJFDL7.png)

In the table above is a visualisation of the ERD diagram, which was used to determine the structure of the database that would be used to store and request data from. The columns have been specified along with the kind of data that is expected for them. The primary key is also defined to allow for efficient data storage. This database was setup on a MYSQL database on Google Cloud Platform, which stored and pulled data to and from the frontend service. 

**CI pipeline Diagram**

![CI](https://i.imgur.com/aIDEI1N.png)

The diagram above lays out the structure of the CI pipeline. To commence the project, a task is taken from the project tracking and developed within the development environment. Once the task is completed, it is updated on the project tracking and pushed to GitHub. Jenkins can then execute a pipeline based on the changes that are commited to GitHub. Testing is carried out in the form of unit tests and once they are completed they images can be built and be pushed to Docker hub with the use of Docker-compose. Jenkins will initialise ansible to create the nodes, which involves installing docker, docker-compose and ansible on them. Ansible will also configure NGINX to behave as a load balancer, which allows the user to connect to the application once it is live. 

## Software Structure

**Services Setup**

![Services](https://i.imgur.com/xnAkwEo.png)

Above is a diagram that displays the paths ways of how the information travels between the services. As mentioned before the system is made of 4 services, service 1 being the frontend with which the user communicates, services 2 and 3 being get requests destinations that are generating a random make and model respectively and service 4 has a post request made to it that returns the number of vowels based on the vehicle generated by services 2 and 3. All this information is stored within the MYSQL database where is can be queried from if needed.

**Swarm Configuration**

The swarm configuration consists of a manager node and a worker node and they are both managed by NGINX. Ansible will install Docker on the swarm manager and worker which will then commence the swarm and join the worker node to the manager node, while multiple containers of the services will be distributed within the swarm. 

**Jenkins**

Jenkins is an automation service which automates many parts of a project which includes, building, testing and deployment of the project. The jenkins pipelines is structured as follows:


* Installing requirements - This is where Docker and Docker-compose are installed as well as ansible.
* Testing - this stage tests each service while producing a coverage report which can be used to debug issues.
* Building and pushing images - Once the Docker and Docker-compose are installed, the images are pushed up to Docker hub.
* Ansible configuration - this stage initliases multiple stages at once, which include configuring the external load balancer, initialiing the docker swarm and preparing for deployment.
* Deployment - This executes the docker stack deploy function but using ansible, which makes it accessible throught the NGINX load balancer. 

**Unit Testing**

Unit tests were written for the three services of this application, the coverage reports are provided to show how much of the code has been tested along with whether it passed or failed.

![S1Test](https://i.imgur.com/beHfY68.png)

Here is the coverage of service 2 which has a test coverage of 88%.

![S2Test](https://i.imgur.com/xsrqdUv.png)

Here is the coverage of service 3 which has a test coverage of 88%.

![S3Test](https://i.imgur.com/EmH9MYh.png)

Here is the coverage of service 4 which has a test coverage of 98%.

## Frontend of the Application

![front](https://i.imgur.com/RHIcozf.png)

Above is a visual presentation of the application running on the website. This is the frontend that is experienced by the user and through which they can interact with the application.

## Ansible Deployment 

![ans](https://i.imgur.com/DoaDfTA.png)

In the image above, you can see that the swarm has been initialised using ansible, which has the swarm manager known as instace-1, the swarm worker known as instance-2 and the nginx services are up and running.

## Jenkins Deployment

![jnk](https://i.imgur.com/0RooyxJ.png)

In the image above, we can observe the attempt on deploying the application through Jenkins which would use ansible to insitialise the swarm and deploy the application. There were many errors that were encountered and majority of them were resolved.

![jnk2](https://i.imgur.com/l5JUYnu.png)

In this image we can see evolution on the progress of deploying the application using jenkins. The furthest the jenkins process was taken to was up to getting Jenkins to configure ansible, however, due to ssh errors ansible wasnt able to connect to the host and deploy the application. 

Furthermore, we can see the build failing on the build step a few builds later, this was due to the VM giving '_no space left on device_' errors which could not be resolved unfortunately. 

## GitHub Merging

![git](https://i.imgur.com/QGaxdeu.png)

In this section a merging of the fully functional application will be made from the development branch onto the main branch of the project.

![git2](https://i.imgur.com/D8rYkhM.png)

Here we can see a pull request being made where it can be analaysed to make sure there are no conflicts within the merge and the changes can be commited straight away.

## Improvements

There are a few ways in which this project could have been improved such as:

* With the help of some more additional time, the errors encountered in the jenkins build could be addressed and resolved.
* More integration testing could be used so that the tests would not fail if the application were to be updated.
* Each of the components that were made for the project could have been done on further features branches, allowing for more careful construction of the project.
* Adding some more frontend user functionality would make the app more appealing to use and to see.

## Licensing

This application can be used by any person of any age, so long as it is not used to harm anyone or to conduct any illegal activities.

# Author

Artas Gill